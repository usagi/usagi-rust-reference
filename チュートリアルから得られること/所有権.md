## 所有権

file: [ownership.rs](.src/ownership.rs)

```rust
fn main ( )
{
  struct S { x: u8, y: Box< u8 > }

  {
    // a は 構造体 S を所有する
    // a は 構造体 S のフィールドそれぞれも所有する
    let a = S { x: 12, y: box 34 };
    println!( "a: x={},y={}", a.x, a.y );
  } // a がスコープアウトすると
    // 所有していたフィールド a.y もデストラクターが呼ばれる。

  // mut はツリー状に所有するオブジェクト全般へ伝搬する。
  let mut b = S { x: 11, y: box 22 };
  b.x  = 33;
  *b.y = 44;
  println!( "b: x={},y={}", b.x, b.y );
}
```

result:
> ```zsh
a: x=12,y=34
b: x=33,y=44
```

### 得られること

1. `let a = `で構造体のオブジェクトを束縛すると `a` は、そのオブジェクトと、そのオブジェクトからツリー上に内包されるフィールドの所有権を得るようだ。
1. `mut`は所有したオブジェクトに対してツリー上に内包されるフィールドにも伝搬するようだ。

### おまけ

1. `Box<type>` は `box` でヒープから確保される値型のボックス化 ( boxing ) されたオブジェクトを保持するための型のようだ。もし、C++で似た状況を想定するのであれば[std::shared_ptr<type>](http://www.cplusplus.com/reference/memory/shared_ptr/)が近いイメージだろうか。しかしこの段階のチュートリアルでは`Box<type>`については解説されていないようだ。
    1. `Box<type>` のオブジェクトは右結合性の `*` 単項演算子を適用すると、ボックス化解除 ( unboxing ) 、 C のポインターに対する間接参照演算子の適用、 C++ の [std::shared_ptr::operator*()](http://www.cplusplus.com/reference/memory/shared_ptr/operator*/)のようにオブジェクトにアクセスできるようだけど、この段階のチュートリアルでは解説されていないようだ。

### この文章と Rust のバージョン

- 執筆: Rust-0.11.0

### 参考

- http://doc.rust-lang.org/tutorial.html#ownership
