## 演算子

file: [operators.rs](.src/operators.rs)

```rust
fn main( )
{
  let a = 111.111e+1f32;
  let b = 222.222e-1f32;

  // 算術演算子
  println!
    ( "{}\n{}\n{}\n{}\n{}\n"
    , a - b
    , a + b
    , a % b
    , a / b
    , a * b
    );
  
  // ビット演算子
  println!
    ( "{}\n{}\n{}\n{}\n{}\n"
    , 65536u >> 8u
    , 1u << 24u
    , 0x1234u & 0b1100110011001100u
    , 0x1234u | 0b1100110011001100u
    , 0x1234u ^ 0b1100110011001100u
    );

  // 比較演算子
  println!
    ( "{}\n{}\n{}\n{}\n{}\n{}\n"
    , a == b
    , a != b
    , a < b
    , a > b
    , a <= b
    , a >= b
    );

  // 遅延評価・比較演算子
  println!
    ( "{}"
    , true && false || true
    );

  // 翻訳時・プリミティブ数値型・型変換演算子
  println!
    ( "{}\n{}\n{}\n{}\n{}\n{}\n"
    , 123456.7890123f64 as i8
    , 123456.7890123f64 as u8
    , 123456.7890123f64 as u16
    , 123456.7890123f64 as u32
    , 123456.7890123f64 as f32
    , 123456.7890123f64
    );
  
  // 翻訳時・同一サイズ型・型変換関数
  let f:f32 = unsafe{ std::mem::transmute( 0x41C80000u32 ) };
  println!( "{}", f );
  
}
```

result:

> ```zsh
> 1088.887817
> 1133.332153
> 22.222166
> 50
> 24691.308594
> 
> 256
> 16777216
> 4
> 57084
> 57080
>  
> false
> true
> false
> true
> false
> true
> 
> true
> 127
> 255
> 65535
> 123456
> 123456.789063
> 123456.789012
> 
> 25
```

### 得られること

1. 算術演算子 `-`(減算) `+`(加算) `%`(剰余) `/`(除算) `*`(乗算) を使えるようだ。
1. ビットワイズ演算子 `>>`(右シフト) `<<`(左シフト) `&`(ビットワイズ論理積) `|`(ビットワイズ論理和) `^`(ビットワイズ排他的論理和) を使えるようだ。
1. 比較演算子 `==`(等しい) `!=`(不等) `<`(小なり) `>`(大なり) `<=`(以下) `>=`(以上) `&&`(論理積) `||`(論理和) を使えるようだ。
    1. `&&` と `||` は遅延評価( lazy )されるようだ。
1. 翻訳時・プリミティブ数値型・型変換演算子 `as` を使えるようだ。
1. 翻訳時・同サイズ型・型変換関数 `std::mem::transmute` なるものがあるようだ。

###この文章と Rust のバージョン

- 執筆: Rust-0.11.0

### 参考

- http://doc.rust-lang.org/tutorial.html#operators
- http://doc.rust-lang.org/std/mem/fn.transmute.html
